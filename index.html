<!DOCTYPE html>
<html>
<head>
    <title>Adaptive Radiance Cascades (WebGPU)</title>
    <style>
        body { margin: 0; background: #1a1a2e; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: system-ui; }
        canvas { border: 1px solid #333; cursor: crosshair; }
        h1 { color: #4a9eff; margin-bottom: 10px; }
        #stats { color: #aaa; margin-top: 8px; font-size: 13px; font-family: monospace; display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        #stats span { background: #252540; padding: 4px 10px; border-radius: 4px; }
        #stats .good { color: #6f6; }
        #stats .neutral { color: #ff6; }
        #controls { margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; background: #2d5a2d; color: white; }
        button.off { background: #5a2d2d; }
        #resetBtn { background: #444; }
        #analyzeBtn { background: #4a4a9e; }
        #compareBtn { background: #9e4a4a; }
        #benchmarkBtn { background: #4a9e4a; }
        #spectrum { margin-top: 10px; background: #111; border: 1px solid #333; }
        #spectrumInfo { color: #aaa; font-size: 12px; margin-top: 5px; max-width: 500px; text-align: center; }
    </style>
</head>
<body>
    <h1>Adaptive Radiance Cascades (WebGPU)</h1>
    <h2><a url="index.html">READ THE FULL PAPER</a></h2>
    <canvas id="canvas" width="512" height="512"></canvas>
    <div id="controls">
        <button id="arcBtn">ARC: ON</button>
        <button id="conservativeBtn">Mode: Auto</button>
        <label style="color:#aaa; margin-left:10px;">Mode: <select id="levelSelect" style="background:#333;color:#fff;border:1px solid #555;padding:2px;">
            <option value="L2">L2 (~40%)</option>
            <option value="L3">L3 (~25%)</option>
            <option value="L4">L4 (~17%)</option>
            <option value="L5">L5 (~10%)</option>
            <option value="auto" selected>Auto (Adaptive)</option>
        </select></label>
        <button id="analyzeBtn">Analyze Frequency</button>
        <button id="compareBtn">Compare Quality</button>
        <button id="benchmarkBtn">Run Full Benchmark</button>
        <button id="resetBtn">Reset (R)</button>
    </div>
    <div id="stats"></div>
    <canvas id="spectrum" width="500" height="200" style="display:none;"></canvas>
    <div id="spectrumInfo" style="display:none;"></div>
    <script type="module">
const WIDTH = 512, HEIGHT = 512;
const N_CASCADES = 5;
const C_DRES = 16;

async function main() {
    const canvas = document.getElementById('canvas');
    const stats = document.getElementById('stats');
    const arcBtn = document.getElementById('arcBtn');
    const resetBtn = document.getElementById('resetBtn');
    
    if (!navigator.gpu) { stats.textContent = 'WebGPU not supported'; return; }
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const ctx = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    ctx.configure({ device, format });

    // State
    let arcEnabled = 1;
    let arcStartLevel = 3;  // Internal: 3 or 4
    let arcMaxSkip = 2;     // 1 = max 2Ã— skip, 2 = max 4Ã— skip
    let arcAutoMode = true; // Start in Auto mode
    let adaptiveLevel = 3;  // Computed level when in auto mode
    let adaptiveMaxSkip = 1; // Computed max skip when in auto mode (default to L4)
    let emissive = 1;
    let hue = 0.1;
    let mouse = { x: 0, y: 0, px: 0, py: 0, down: false };

    // Calculate cascade sizes
    const c0_sRes = Math.floor(Math.sqrt(WIDTH * HEIGHT / 4));
    const levels = [];
    let totalSize = 0;
    for (let n = 0; n < N_CASCADES; n++) {
        const sRes = c0_sRes >> n;
        const dRes = n === 0 ? 1 : C_DRES << (2 * (n - 1));
        const size = sRes * sRes * dRes;
        levels.push({ level: n, sRes, dRes, offset: totalSize, size });
        totalSize += size;
    }
    
    // Calculate ray counts for stats
    function calculateRayCounts(useArc, startLevel, maxSkipBits = 2) {
        let totalRays = 0;
        const breakdown = [];
        for (let n = 0; n < N_CASCADES; n++) {
            const sRes = c0_sRes >> n;
            const dRes = n === 0 ? 1 : C_DRES << (2 * (n - 1));
            const nDirs = C_DRES << (2 * n);
            const probeCount = sRes * sRes;
            const baseRaysPerProbe = nDirs / dRes;  // rays per direction slot
            
            let step = 1;
            if (useArc && n >= startLevel) {
                step = 1 << Math.min(n - startLevel + 1, maxSkipBits);
            }
            // Total rays = probes Ã— direction_slots Ã— rays_per_slot
            // = probes Ã— dRes Ã— (baseRaysPerProbe / step)
            // = probes Ã— nDirs / step
            const raysPerSlot = Math.ceil(baseRaysPerProbe / step);
            const levelRays = probeCount * dRes * raysPerSlot;
            totalRays += levelRays;
            breakdown.push({ level: n, probes: probeCount, dRes, raysPerSlot, totalRays: levelRays, step });
        }
        return { total: totalRays, breakdown };
    }
    
    const raysNoArc = calculateRayCounts(false, 2, 2).total;
    
    function getEffectiveLevel() {
        return arcAutoMode ? adaptiveLevel : arcStartLevel;
    }
    
    function getEffectiveMaxSkip() {
        return arcAutoMode ? adaptiveMaxSkip : arcMaxSkip;
    }
    
    function getRaysForCurrentSettings() {
        return calculateRayCounts(arcEnabled === 1, getEffectiveLevel(), getEffectiveMaxSkip()).total;
    }
    
    console.log('=== Ray Count Analysis ===');
    console.log(`Canvas: ${WIDTH}x${HEIGHT}, Cascade 0 resolution: ${c0_sRes}x${c0_sRes}`);
    console.log('');
    const statsL2 = calculateRayCounts(true, 2);
    const statsL3 = calculateRayCounts(true, 3);
    const statsL4 = calculateRayCounts(true, 4);
    console.log(`Without ARC: ${raysNoArc.toLocaleString()} rays/frame`);
    console.log(`Start Level 2 (aggressive): ${statsL2.total.toLocaleString()} rays/frame (${((1 - statsL2.total/raysNoArc) * 100).toFixed(1)}% reduction)`);
    console.log(`Start Level 3 (conservative): ${statsL3.total.toLocaleString()} rays/frame (${((1 - statsL3.total/raysNoArc) * 100).toFixed(1)}% reduction)`);
    console.log(`Start Level 4 (ultra-safe): ${statsL4.total.toLocaleString()} rays/frame (${((1 - statsL4.total/raysNoArc) * 100).toFixed(1)}% reduction)`);
    
    // Frame timing
    let frameTimes = [];
    let lastTime = performance.now();

    // Buffers
    const sdfBuffers = [
        device.createBuffer({ size: WIDTH * HEIGHT * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST }),
        device.createBuffer({ size: WIDTH * HEIGHT * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST })
    ];
    const cascadeBuffer = device.createBuffer({ size: totalSize * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    const uniformBuffer = device.createBuffer({ size: 64, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    const paramsBuffer = device.createBuffer({ size: 32, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

    // Initialize SDF
    function initSdf() {
        const sdfData = new Float32Array(WIDTH * HEIGHT * 4);
        for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
                const i = (y * WIDTH + x) * 4;
                const px = x + 0.5, py = y + 0.5;
                
                let sd = 1000, em = [0, 0, 0];
                
                // Walls only - no emitters
                const w1 = Math.max(Math.abs(px - 160) - 10, Math.abs(py - HEIGHT/2) - 90);
                if (w1 < sd) { sd = w1; em = [0,0,0]; }
                
                const w2 = Math.max(Math.abs(px - WIDTH + 160) - 10, Math.abs(py - HEIGHT/2) - 90);
                if (w2 < sd) { sd = w2; em = [0,0,0]; }
                
                sdfData[i] = sd;
                sdfData[i+1] = em[0];
                sdfData[i+2] = em[1];
                sdfData[i+3] = em[2];
            }
        }
        device.queue.writeBuffer(sdfBuffers[0], 0, sdfData);
        device.queue.writeBuffer(sdfBuffers[1], 0, sdfData);
    }
    initSdf();

    // SDF Update shader
    const sdfUpdateCode = /* wgsl */`
        struct Uniforms { time: f32, frame: u32, arcEnabled: u32, arcStartLevel: u32, arcMaxSkip: u32, mouseX: f32, mouseY: f32, mousePX: f32, mousePY: f32, mouseDown: u32, emissive: u32, hue: f32 }
        @group(0) @binding(0) var<uniform> u: Uniforms;
        @group(0) @binding(1) var<storage, read> sdfIn: array<vec4f>;
        @group(0) @binding(2) var<storage, read_write> sdfOut: array<vec4f>;
        
        fn hsvToRgb(h: f32, s: f32, v: f32) -> vec3f {
            let c = v * s;
            let x = c * (1.0 - abs(fract(h * 6.0) * 2.0 - 1.0));
            let m = v - c;
            var rgb: vec3f;
            let hi = i32(h * 6.0) % 6;
            if (hi == 0) { rgb = vec3f(c, x, 0.0); }
            else if (hi == 1) { rgb = vec3f(x, c, 0.0); }
            else if (hi == 2) { rgb = vec3f(0.0, c, x); }
            else if (hi == 3) { rgb = vec3f(0.0, x, c); }
            else if (hi == 4) { rgb = vec3f(x, 0.0, c); }
            else { rgb = vec3f(c, 0.0, x); }
            return rgb + m;
        }
        
        fn sdSegment(p: vec2f, a: vec2f, b: vec2f) -> f32 {
            let pa = p - a; let ba = b - a;
            let h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
            return length(pa - ba * h);
        }
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) gid: vec3u) {
            let x = gid.x; let y = gid.y;
            if (x >= ${WIDTH}u || y >= ${HEIGHT}u) { return; }
            let idx = y * ${WIDTH}u + x;
            var v = sdfIn[idx];
            
            if (u.mouseDown == 1u) {
                let p = vec2f(f32(x) + 0.5, f32(y) + 0.5);
                let brushR = 8.0;
                let d = sdSegment(p, vec2f(u.mousePX, u.mousePY), vec2f(u.mouseX, u.mouseY)) - brushR;
                if (d < v.r) {
                    v.r = d;
                    if (u.emissive == 1u) {
                        v = vec4f(d, hsvToRgb(u.hue, 0.8, 1.0));
                    } else {
                        v = vec4f(d, 0.0, 0.0, 0.0);
                    }
                }
            }
            sdfOut[idx] = v;
        }
    `;

    // Cascade compute shader
    const cascadeCode = /* wgsl */`
        const PI: f32 = 3.14159265359;
        const TAU: f32 = 6.28318530718;
        const WIDTH: f32 = ${WIDTH}.0;
        const HEIGHT: f32 = ${HEIGHT}.0;
        const N_CASCADES: i32 = ${N_CASCADES};
        const C_DRES: i32 = ${C_DRES};
        const C0_SRES: i32 = ${c0_sRes};
        
        struct Uniforms { time: f32, frame: u32, arcEnabled: u32, arcStartLevel: u32, arcMaxSkip: u32, pad1: f32, pad2: f32, pad3: f32 }
        struct Params { level: u32, sRes: u32, dRes: u32, offset: u32, tMin: f32, tMax: f32 }
        
        @group(0) @binding(0) var<uniform> u: Uniforms;
        @group(0) @binding(1) var<storage, read> sdf: array<vec4f>;
        @group(0) @binding(2) var<storage, read_write> cascade: array<vec4f>;
        @group(0) @binding(3) var<uniform> params: Params;
        
        fn sampleSdf(p: vec2f) -> vec4f {
            let ix = i32(p.x); let iy = i32(p.y);
            if (ix < 0 || ix >= i32(WIDTH) || iy < 0 || iy >= i32(HEIGHT)) { return vec4f(1000.0, 0.0, 0.0, 0.0); }
            return sdf[iy * i32(WIDTH) + ix];
        }
        
        fn trace(ro: vec2f, rd: vec2f, maxDist: f32) -> f32 {
            var t = 0.0;
            for (var i = 0; i < 256; i++) {
                let p = ro + rd * t;
                if (p.x < 0.0 || p.x >= WIDTH || p.y < 0.0 || p.y >= HEIGHT) { return -1.0; }
                let d = sampleSdf(p).r;
                t += abs(d);
                if (t >= maxDist) { break; }
                if (t > 0.2 && d < 1.0) { return t; }
            }
            return -1.0;
        }
        
        fn radiance(ro: vec2f, rd: vec2f, maxDist: f32) -> vec4f {
            let start = sampleSdf(ro);
            if (start.r <= 0.0) { return vec4f(start.gba, 0.0); }
            let t = trace(ro, rd, maxDist);
            if (t < 0.0) { return vec4f(0.0, 0.0, 0.0, 1.0); }
            let hit = sampleSdf(ro + rd * t);
            return vec4f(hit.gba, 0.0);
        }
        
        fn getDRes(level: i32) -> i32 { if (level == 0) { return 1; } return C_DRES << u32(2 * (level - 1)); }
        
        fn getOffset(level: i32) -> i32 {
            var off = 0;
            for (var l = 0; l < level; l++) { off += (C0_SRES >> u32(l)) * (C0_SRES >> u32(l)) * getDRes(l); }
            return off;
        }
        
        fn cascadeRead(level: i32, px: i32, py: i32, dir: i32) -> vec4f {
            let sRes = C0_SRES >> u32(level);
            let dRes = getDRes(level);
            let idx = getOffset(level) + clamp(dir, 0, dRes-1) + dRes * (clamp(px, 0, sRes-1) + sRes * clamp(py, 0, sRes-1));
            return cascade[idx];
        }
        
        fn sky(a0: f32, a1: f32) -> vec3f { return vec3f(0.02, 0.03, 0.05) * (a1 - a0); }
        
        fn arcStep(level: i32) -> i32 {
            if (u.arcEnabled == 0u) { return 1; }
            let startLevel = i32(u.arcStartLevel);
            let maxSkipBits = i32(u.arcMaxSkip);  // 1 = max 2Ã— skip, 2 = max 4Ã— skip
            if (level < startLevel) { return 1; }
            return 1 << u32(min(level - startLevel + 1, maxSkipBits));
        }
        
        @compute @workgroup_size(64)
        fn main(@builtin(global_invocation_id) gid: vec3u) {
            let idx = gid.x;
            let level = i32(params.level);
            let sRes = i32(params.sRes);
            let dRes = i32(params.dRes);
            if (idx >= u32(sRes * sRes * dRes)) { return; }
            
            let d = i32(idx) % dRes;
            let rem = i32(idx) / dRes;
            let px = rem % sRes;
            let py = rem / sRes;
            
            let nDirs = C_DRES << u32(2 * level);
            let probePos = (vec2f(f32(px), f32(py)) + 0.5) / f32(sRes) * vec2f(WIDTH, HEIGHT);
            
            var s = vec4f(0.0);
            let baseCount = nDirs / dRes;
            let step = arcStep(level);
            var samples = 0;
            
            for (var i = 0; i < baseCount; i += step) {
                samples++;
                let rayIdx = 4 * d + i;
                let angle = (f32(rayIdx) + 0.5) / f32(nDirs) * TAU;
                let rd = vec2f(cos(angle), sin(angle));
                var si = radiance(probePos + rd * params.tMin, rd, params.tMax - params.tMin);
                
                if (si.a > 0.0) {
                    if (level == N_CASCADES - 1) {
                        let a0 = f32(rayIdx) / f32(nDirs) * TAU;
                        let a1 = f32(rayIdx + 1) / f32(nDirs) * TAU;
                        si = vec4f(si.rgb + sky(a0, a1) / (a1 - a0), 0.0);
                    } else {
                        let pf = (vec2f(f32(px), f32(py)) + 0.5) / 2.0;
                        let qi = vec2i(i32(round(pf.x)), i32(round(pf.y))) - 1;
                        let w = pf - vec2f(f32(qi.x), f32(qi.y)) - 0.5;
                        let S = mix(mix(cascadeRead(level+1, qi.x, qi.y, rayIdx), cascadeRead(level+1, qi.x+1, qi.y, rayIdx), w.x),
                                    mix(cascadeRead(level+1, qi.x, qi.y+1, rayIdx), cascadeRead(level+1, qi.x+1, qi.y+1, rayIdx), w.x), w.y);
                        si = vec4f(si.rgb + si.a * S.rgb, si.a * S.a);
                    }
                }
                s += si;
            }
            cascade[i32(params.offset) + i32(idx)] = s / f32(samples);
        }
    `;

    // Render shader
    const renderCode = /* wgsl */`
        const WIDTH: f32 = ${WIDTH}.0;
        const HEIGHT: f32 = ${HEIGHT}.0;
        const TAU: f32 = 6.28318530718;
        const C0_SRES: f32 = ${c0_sRes}.0;
        
        @group(0) @binding(0) var<storage, read> sdf: array<vec4f>;
        @group(0) @binding(1) var<storage, read> cascade: array<vec4f>;
        
        struct VSOut { @builtin(position) pos: vec4f, @location(0) uv: vec2f }
        @vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {
            let p = array(vec2f(-1,-1), vec2f(1,-1), vec2f(-1,1), vec2f(-1,1), vec2f(1,-1), vec2f(1,1));
            var o: VSOut; o.pos = vec4f(p[i], 0, 1); o.uv = p[i] * 0.5 + 0.5; return o;
        }
        
        fn cascadeFetch(px: i32, py: i32) -> vec4f {
            let sRes = i32(C0_SRES);
            return cascade[clamp(px, 0, sRes-1) + sRes * clamp(py, 0, sRes-1)];
        }
        
        @fragment fn fs(v: VSOut) -> @location(0) vec4f {
            let fragCoord = v.uv * vec2f(WIDTH, HEIGHT);
            let p = fragCoord / vec2f(WIDTH, HEIGHT) * C0_SRES;
            let qi = vec2i(i32(round(p.x)), i32(round(p.y))) - 1;
            let w = p - vec2f(f32(qi.x), f32(qi.y)) - 0.5;
            
            var fluence = mix(mix(cascadeFetch(qi.x, qi.y), cascadeFetch(qi.x+1, qi.y), w.x),
                              mix(cascadeFetch(qi.x, qi.y+1), cascadeFetch(qi.x+1, qi.y+1), w.x), w.y).rgb * TAU;
            
            let sdfVal = sdf[i32(fragCoord.y) * i32(WIDTH) + i32(fragCoord.x)];
            let edgeMix = clamp(3.0 - sdfVal.r, 0.0, 1.0);
            fluence = mix(fluence, sdfVal.gba * TAU, edgeMix);
            
            let color = 1.0 - 1.0 / pow(1.0 + fluence, vec3f(2.5));
            
            return vec4f(color, 1.0);
        }
    `;

    // Pipelines
    const sdfUpdatePipeline = device.createComputePipeline({
        layout: 'auto', compute: { module: device.createShaderModule({ code: sdfUpdateCode }), entryPoint: 'main' }
    });
    const cascadePipeline = device.createComputePipeline({
        layout: 'auto', compute: { module: device.createShaderModule({ code: cascadeCode }), entryPoint: 'main' }
    });
    const renderPipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: { module: device.createShaderModule({ code: renderCode }), entryPoint: 'vs' },
        fragment: { module: device.createShaderModule({ code: renderCode }), entryPoint: 'fs', targets: [{ format }] }
    });

    // Input
    canvas.addEventListener('mousedown', e => {
        const r = canvas.getBoundingClientRect();
        mouse.x = mouse.px = e.clientX - r.left;
        mouse.y = mouse.py = HEIGHT - (e.clientY - r.top);
        mouse.down = true;
    });
    canvas.addEventListener('mousemove', e => {
        if (mouse.down) {
            const r = canvas.getBoundingClientRect();
            mouse.px = mouse.x; mouse.py = mouse.y;
            mouse.x = e.clientX - r.left;
            mouse.y = HEIGHT - (e.clientY - r.top);
        }
    });
    canvas.addEventListener('mouseup', () => { 
        mouse.down = false;
        // Re-analyze after drawing if in auto mode
        if (arcAutoMode) {
            setTimeout(() => analyzeSceneForAdaptiveLevel(), 300);
        }
    });
    canvas.addEventListener('mouseleave', () => { mouse.down = false; });
    
    document.addEventListener('keydown', e => {
        if (e.code === 'Space') { emissive = 1 - emissive; e.preventDefault(); }
        if (e.code === 'KeyR') { 
            initSdf(); 
            if (arcAutoMode) setTimeout(() => analyzeSceneForAdaptiveLevel(), 200);
        }
        if (e.code === 'KeyA') { arcEnabled = 1 - arcEnabled; updateArcBtn(); }
        if (e.code === 'KeyC') { 
            // Cycle: L3 -> L4 -> L5 -> Auto -> L3...
            conservativeBtn.click();
        }
    });
    
    function updateArcBtn() {
        arcBtn.textContent = `ARC: ${arcEnabled ? 'ON' : 'OFF'}`;
        arcBtn.className = arcEnabled ? '' : 'off';
        updateStatsNow();
    }
    function updateConservativeBtn() {
        const modeNames = { 2: 'L2 (Aggressive)', 3: 'L3 (Conservative)', 4: 'L5 (Ultra-safe)' };
        if (arcAutoMode) {
            // Convert internal representation to display name
            const autoModeStr = (adaptiveLevel === 4) ? 'L5' : (adaptiveLevel === 2) ? 'L2' : (adaptiveMaxSkip === 1 ? 'L4' : 'L3');
            conservativeBtn.textContent = `Mode: Auto (${autoModeStr})`;
            conservativeBtn.className = '';
        } else {
            // Manual mode display
            let modeStr;
            if (arcStartLevel === 4) modeStr = 'L5 (Ultra-safe)';
            else if (arcStartLevel === 2) modeStr = 'L2 (Aggressive)';
            else if (arcMaxSkip === 1) modeStr = 'L4 (Safe)';
            else modeStr = 'L3 (Conservative)';
            conservativeBtn.textContent = `Mode: ${modeStr}`;
            conservativeBtn.className = arcStartLevel >= 3 ? '' : 'off';
        }
        updateStatsNow();
    }
    
    function updateStatsNow() {
        const effectiveLevel = getEffectiveLevel();
        const effectiveMaxSkip = getEffectiveMaxSkip();
        const currentRays = arcEnabled ? getRaysForCurrentSettings() : raysNoArc;
        const savedRays = raysNoArc - currentRays;
        const savedPercent = ((savedRays / raysNoArc) * 100).toFixed(1);
        
        const formatRays = (n) => n >= 1000000 ? (n/1000000).toFixed(1) + 'M' : (n/1000).toFixed(0) + 'K';
        
        // Convert to display name
        let modeStr;
        if (arcAutoMode) {
            modeStr = (effectiveLevel === 4) ? 'Auto:L5' : (effectiveLevel === 2) ? 'Auto:L2' : (effectiveMaxSkip === 1 ? 'Auto:L4' : 'Auto:L3');
        } else {
            modeStr = (effectiveLevel === 4) ? 'L5' : (effectiveLevel === 2) ? 'L2' : (effectiveMaxSkip === 1 ? 'L4' : 'L3');
        }
        stats.innerHTML = `
            <span>FPS: <b>--</b></span>
            <span>Frame: <b>-- ms</b></span>
            <span>Rays: <b>${formatRays(currentRays)}</b> / ${formatRays(raysNoArc)}</span>
            <span class="${arcEnabled ? 'good' : 'neutral'}">Saved: <b>${arcEnabled ? savedPercent + '%' : '0%'}</b></span>
        `;
    }
    
    const conservativeBtn = document.getElementById('conservativeBtn');
    const levelSelect = document.getElementById('levelSelect');
    
    arcBtn.onclick = () => { arcEnabled = 1 - arcEnabled; updateArcBtn(); };
    conservativeBtn.onclick = () => { 
        // Cycle through modes: L2 -> L3 -> L4 -> L5 -> Auto
        if (arcAutoMode) {
            arcAutoMode = false;
            arcStartLevel = 2; arcMaxSkip = 2;  // L2
            levelSelect.value = 'L2';
        } else if (arcStartLevel === 2) {
            arcStartLevel = 3; arcMaxSkip = 2;  // L3
            levelSelect.value = 'L3';
        } else if (arcStartLevel === 3 && arcMaxSkip === 2) {
            arcStartLevel = 3; arcMaxSkip = 1;  // L4
            levelSelect.value = 'L4';
        } else if (arcStartLevel === 3 && arcMaxSkip === 1) {
            arcStartLevel = 4; arcMaxSkip = 2;  // L5
            levelSelect.value = 'L5';
        } else {
            arcAutoMode = true;
            levelSelect.value = 'auto';
            // Hot start: analyze immediately
            setTimeout(() => analyzeSceneForAdaptiveLevel(), 100);
        }
        updateConservativeBtn(); 
    };
    levelSelect.onchange = () => {
        const val = levelSelect.value;
        if (val === 'auto') {
            arcAutoMode = true;
            // Hot start: analyze immediately
            setTimeout(() => analyzeSceneForAdaptiveLevel(), 100);
        } else {
            arcAutoMode = false;
            // L2: startLevel=2, maxSkip=2
            // L3: startLevel=3, maxSkip=2
            // L4: startLevel=3, maxSkip=1
            // L5: startLevel=4, maxSkip=2
            if (val === 'L2') {
                arcStartLevel = 2; arcMaxSkip = 2;
            } else if (val === 'L3') {
                arcStartLevel = 3; arcMaxSkip = 2;
            } else if (val === 'L4') {
                arcStartLevel = 3; arcMaxSkip = 1;
            } else if (val === 'L5') {
                arcStartLevel = 4; arcMaxSkip = 2;
            }
        }
        updateConservativeBtn();
    };
    resetBtn.onclick = () => { 
        initSdf(); 
        if (arcAutoMode) {
            // Re-analyze after reset
            setTimeout(() => analyzeSceneForAdaptiveLevel(), 200);
        }
    };
    
    // Frequency analysis
    const analyzeBtn = document.getElementById('analyzeBtn');
    const spectrumCanvas = document.getElementById('spectrum');
    const spectrumInfo = document.getElementById('spectrumInfo');
    const specCtx = spectrumCanvas.getContext('2d');
    
    // Simple DFT (we don't need FFT for small sample counts)
    function computeDFT(samples) {
        const N = samples.length;
        const magnitudes = [];
        for (let k = 0; k < N / 2; k++) {  // Only need half due to symmetry
            let re = 0, im = 0;
            for (let n = 0; n < N; n++) {
                const angle = -2 * Math.PI * k * n / N;
                re += samples[n] * Math.cos(angle);
                im += samples[n] * Math.sin(angle);
            }
            magnitudes.push(Math.sqrt(re * re + im * im) / N);
        }
        return magnitudes;
    }
    
    // Compute effective bandwidth (frequency where 90% of energy is contained)
    function computeBandwidth(magnitudes) {
        const totalEnergy = magnitudes.reduce((a, b) => a + b * b, 0);
        let cumulative = 0;
        for (let k = 0; k < magnitudes.length; k++) {
            cumulative += magnitudes[k] * magnitudes[k];
            if (cumulative >= 0.9 * totalEnergy) {
                return (k + 1) / magnitudes.length;  // Normalized 0-1
            }
        }
        return 1.0;
    }
    
    async function analyzeFrequency() {
        analyzeBtn.textContent = 'Analyzing...';
        analyzeBtn.disabled = true;
        
        // Create staging buffer for readback
        const stagingBuffer = device.createBuffer({
            size: totalSize * 16,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
        });
        
        // Copy cascade data to staging buffer
        const encoder = device.createCommandEncoder();
        encoder.copyBufferToBuffer(cascadeBuffer, 0, stagingBuffer, 0, totalSize * 16);
        device.queue.submit([encoder.finish()]);
        
        // Read back data
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        const cascadeData = new Float32Array(stagingBuffer.getMappedRange().slice(0));
        stagingBuffer.unmap();
        stagingBuffer.destroy();
        
        // Analyze each level (skip level 0 - only 1 direction)
        const results = [];
        const spectraPerLevel = [];
        
        for (let lvl = 1; lvl < N_CASCADES; lvl++) {
            const lv = levels[lvl];
            const nDirs = lv.dRes;  // Angular samples at this level
            
            // Sample several probes at this level
            const numProbes = Math.min(16, lv.sRes * lv.sRes);
            const probeStep = Math.floor(lv.sRes * lv.sRes / numProbes);
            
            const allMagnitudes = [];
            let totalBandwidth = 0;
            
            for (let p = 0; p < numProbes; p++) {
                const probeIdx = p * probeStep;
                
                // Extract angular samples for this probe
                const angularSamples = [];
                for (let d = 0; d < nDirs; d++) {
                    const idx = lv.offset + probeIdx * nDirs + d;
                    // Use luminance (sum RGB)
                    const r = cascadeData[idx * 4 + 0];
                    const g = cascadeData[idx * 4 + 1];
                    const b = cascadeData[idx * 4 + 2];
                    angularSamples.push(r + g + b);
                }
                
                // Compute frequency spectrum
                const mags = computeDFT(angularSamples);
                const bw = computeBandwidth(mags);
                totalBandwidth += bw;
                
                // Accumulate magnitudes
                if (allMagnitudes.length === 0) {
                    allMagnitudes.push(...mags);
                } else {
                    for (let k = 0; k < mags.length; k++) {
                        allMagnitudes[k] += mags[k];
                    }
                }
            }
            
            // Average
            const avgBandwidth = totalBandwidth / numProbes;
            const avgMagnitudes = allMagnitudes.map(m => m / numProbes);
            
            results.push({
                level: lvl,
                directions: nDirs,
                bandwidth90: avgBandwidth,
                avgMagnitudes
            });
            spectraPerLevel.push(avgMagnitudes);
        }
        
        // Draw spectrum chart
        spectrumCanvas.style.display = 'block';
        spectrumInfo.style.display = 'block';
        
        const W = spectrumCanvas.width, H = spectrumCanvas.height;
        specCtx.fillStyle = '#111';
        specCtx.fillRect(0, 0, W, H);
        
        // Find max magnitude for scaling
        let maxMag = 0;
        for (const spectrum of spectraPerLevel) {
            for (const m of spectrum) maxMag = Math.max(maxMag, m);
        }
        
        // Colors for each level
        const colors = ['#ff6666', '#66ff66', '#6666ff', '#ffff66', '#ff66ff'];
        
        // Draw axes
        specCtx.strokeStyle = '#444';
        specCtx.beginPath();
        specCtx.moveTo(50, 10);
        specCtx.lineTo(50, H - 30);
        specCtx.lineTo(W - 10, H - 30);
        specCtx.stroke();
        
        // Labels
        specCtx.fillStyle = '#888';
        specCtx.font = '11px monospace';
        specCtx.fillText('Power', 5, 20);
        specCtx.fillText('Angular Frequency (normalized)', W/2 - 80, H - 5);
        specCtx.fillText('0', 47, H - 18);
        specCtx.fillText('0.5', W/2, H - 18);
        
        // Draw spectra
        const plotW = W - 70, plotH = H - 50;
        
        for (let i = 0; i < spectraPerLevel.length; i++) {
            const spectrum = spectraPerLevel[i];
            const lvl = i + 1;
            
            specCtx.strokeStyle = colors[i % colors.length];
            specCtx.lineWidth = 2;
            specCtx.beginPath();
            
            for (let k = 0; k < spectrum.length; k++) {
                const x = 50 + (k / spectrum.length) * plotW;
                const y = (H - 30) - (spectrum[k] / maxMag) * plotH;
                if (k === 0) specCtx.moveTo(x, y);
                else specCtx.lineTo(x, y);
            }
            specCtx.stroke();
            
            // Legend
            specCtx.fillStyle = colors[i % colors.length];
            specCtx.fillText(`L${lvl}`, W - 50, 20 + i * 15);
        }
        
        // Report results
        let infoText = '<b>Angular Frequency Analysis (90% energy bandwidth):</b><br>';
        for (const r of results) {
            const pct = (r.bandwidth90 * 100).toFixed(1);
            infoText += `Level ${r.level}: ${r.directions} dirs â†’ ${pct}% of Nyquist needed<br>`;
        }
        
        // Key insight
        const l1bw = results[0].bandwidth90;
        const l3bw = results[2] ? results[2].bandwidth90 : results[1].bandwidth90;
        const reduction = ((1 - l3bw / l1bw) * 100).toFixed(0);
        infoText += `<br><b>â†’ Level 3+ uses ~${reduction}% less bandwidth than Level 1</b>`;
        
        spectrumInfo.innerHTML = infoText;
        
        // Console output for paper
        console.log('=== Frequency Analysis Results ===');
        for (const r of results) {
            console.log(`Level ${r.level}: ${r.directions} directions, 90% bandwidth at ${(r.bandwidth90 * 100).toFixed(1)}% of Nyquist`);
        }
        
        analyzeBtn.textContent = 'Analyze Frequency';
        analyzeBtn.disabled = false;
    }
    
    analyzeBtn.onclick = analyzeFrequency;
    
    // Quality comparison (PSNR/SSIM)
    const compareBtn = document.getElementById('compareBtn');
    let comparing = false;
    let compareState = null;
    
    function computePSNR(img1, img2) {
        let mse = 0;
        for (let i = 0; i < img1.length; i += 4) {
            const dr = img1[i] - img2[i];
            const dg = img1[i+1] - img2[i+1];
            const db = img1[i+2] - img2[i+2];
            mse += (dr*dr + dg*dg + db*db) / 3;
        }
        mse /= (img1.length / 4);
        if (mse === 0) return Infinity;
        return 10 * Math.log10(255 * 255 / mse);
    }
    
    function computeSSIM(img1, img2, width, height) {
        // Simplified SSIM - compute on luminance
        const L = 255;
        const k1 = 0.01, k2 = 0.03;
        const c1 = (k1 * L) ** 2;
        const c2 = (k2 * L) ** 2;
        
        // Convert to luminance
        const lum1 = [], lum2 = [];
        for (let i = 0; i < img1.length; i += 4) {
            lum1.push(0.299 * img1[i] + 0.587 * img1[i+1] + 0.114 * img1[i+2]);
            lum2.push(0.299 * img2[i] + 0.587 * img2[i+1] + 0.114 * img2[i+2]);
        }
        
        // Global statistics (simplified - proper SSIM uses windows)
        const n = lum1.length;
        let mu1 = 0, mu2 = 0;
        for (let i = 0; i < n; i++) {
            mu1 += lum1[i];
            mu2 += lum2[i];
        }
        mu1 /= n;
        mu2 /= n;
        
        let sigma1 = 0, sigma2 = 0, sigma12 = 0;
        for (let i = 0; i < n; i++) {
            const d1 = lum1[i] - mu1;
            const d2 = lum2[i] - mu2;
            sigma1 += d1 * d1;
            sigma2 += d2 * d2;
            sigma12 += d1 * d2;
        }
        sigma1 = Math.sqrt(sigma1 / n);
        sigma2 = Math.sqrt(sigma2 / n);
        sigma12 /= n;
        
        const ssim = ((2 * mu1 * mu2 + c1) * (2 * sigma12 + c2)) / 
                     ((mu1 * mu1 + mu2 * mu2 + c1) * (sigma1 * sigma1 + sigma2 * sigma2 + c2));
        return ssim;
    }
    
    async function compareQuality() {
        compareBtn.textContent = 'Comparing...';
        compareBtn.disabled = true;
        
        const savedArc = arcEnabled;
        const savedLevel = arcStartLevel;
        
        // Helper to render N frames and capture
        async function captureAfterFrames(n) {
            for (let i = 0; i < n; i++) {
                await new Promise(r => requestAnimationFrame(r));
            }
            // Read pixels from canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = WIDTH;
            tempCanvas.height = HEIGHT;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            return tempCtx.getImageData(0, 0, WIDTH, HEIGHT).data;
        }
        
        // Capture reference (ARC OFF)
        arcEnabled = 0;
        const refImage = await captureAfterFrames(30);
        
        // Capture with ARC ON (level 2 - aggressive ~40%)
        arcEnabled = 1;
        arcStartLevel = 2;
        const arcLevel2Image = await captureAfterFrames(30);
        
        // Capture with ARC ON (level 3 - conservative ~25%)
        arcStartLevel = 3;
        const arcLevel3Image = await captureAfterFrames(30);
        
        // Capture with ARC ON (level 4 - ultra-safe ~15%)
        arcStartLevel = 4;
        const arcLevel4Image = await captureAfterFrames(30);
        
        // Restore state
        arcEnabled = savedArc;
        arcStartLevel = savedLevel;
        
        // Compute metrics
        const psnrL2 = computePSNR(refImage, arcLevel2Image);
        const ssimL2 = computeSSIM(refImage, arcLevel2Image, WIDTH, HEIGHT);
        
        const psnrL3 = computePSNR(refImage, arcLevel3Image);
        const ssimL3 = computeSSIM(refImage, arcLevel3Image, WIDTH, HEIGHT);
        
        const psnrL4 = computePSNR(refImage, arcLevel4Image);
        const ssimL4 = computeSSIM(refImage, arcLevel4Image, WIDTH, HEIGHT);
        
        // Calculate ray reductions
        const reductionL2 = ((1 - calculateRayCounts(true, 2).total / raysNoArc) * 100).toFixed(0);
        const reductionL3 = ((1 - calculateRayCounts(true, 3).total / raysNoArc) * 100).toFixed(0);
        const reductionL4 = ((1 - calculateRayCounts(true, 4).total / raysNoArc) * 100).toFixed(0);
        
        // Display results
        spectrumCanvas.style.display = 'none';
        spectrumInfo.style.display = 'block';
        
        let html = '<b>Quality Comparison (vs ARC OFF baseline):</b><br><br>';
        html += '<table style="margin:0 auto; text-align:left; border-collapse:collapse;">';
        html += '<tr style="border-bottom:1px solid #444;"><th style="padding:4px 12px;">Mode</th><th style="padding:4px 12px;">PSNR</th><th style="padding:4px 12px;">SSIM</th><th style="padding:4px 12px;">Quality</th></tr>';
        
        const fmtPSNR = (p) => p === Infinity ? 'âˆž (identical)' : p.toFixed(1) + ' dB';
        const fmtQuality = (p) => p >= 50 ? 'ðŸŸ¢ Imperceptible' : p >= 40 ? 'ðŸŸ¡ Minimal' : 'ðŸ”´ Visible';
        
        html += `<tr><td style="padding:4px 12px;">Level 4 / Ultra-safe (${reductionL4}% reduction)</td><td style="padding:4px 12px;">${fmtPSNR(psnrL4)}</td><td style="padding:4px 12px;">${ssimL4.toFixed(4)}</td><td style="padding:4px 12px;">${fmtQuality(psnrL4)}</td></tr>`;
        html += `<tr><td style="padding:4px 12px;">Level 3 / Conservative (${reductionL3}% reduction)</td><td style="padding:4px 12px;">${fmtPSNR(psnrL3)}</td><td style="padding:4px 12px;">${ssimL3.toFixed(4)}</td><td style="padding:4px 12px;">${fmtQuality(psnrL3)}</td></tr>`;
        html += `<tr><td style="padding:4px 12px;">Level 2 / Aggressive (${reductionL2}% reduction)</td><td style="padding:4px 12px;">${fmtPSNR(psnrL2)}</td><td style="padding:4px 12px;">${ssimL2.toFixed(4)}</td><td style="padding:4px 12px;">${fmtQuality(psnrL2)}</td></tr>`;
        html += '</table>';
        
        html += '<br><small>PSNR > 50 dB = visually identical | PSNR > 40 dB = imperceptible | SSIM > 0.99 = excellent</small>';
        
        spectrumInfo.innerHTML = html;
        
        // Console output
        console.log('=== Quality Comparison Results ===');
        console.log(`Level 4 (${reductionL4}% reduction): PSNR = ${fmtPSNR(psnrL4)}, SSIM = ${ssimL4.toFixed(4)}`);
        console.log(`Level 3 (${reductionL3}% reduction): PSNR = ${fmtPSNR(psnrL3)}, SSIM = ${ssimL3.toFixed(4)}`);
        console.log(`Level 2 (${reductionL2}% reduction): PSNR = ${fmtPSNR(psnrL2)}, SSIM = ${ssimL2.toFixed(4)}`);
        
        compareBtn.textContent = 'Compare Quality';
        compareBtn.disabled = false;
    }
    
    compareBtn.onclick = compareQuality;
    
    // Full automated benchmark
    const benchmarkBtn = document.getElementById('benchmarkBtn');
    
    function createRandomScene(numLights, numOccluders) {
        const sdfData = new Float32Array(WIDTH * HEIGHT * 4);
        
        // Initialize with large distance
        for (let i = 0; i < sdfData.length; i += 4) {
            sdfData[i] = 1000;
            sdfData[i+1] = 0;
            sdfData[i+2] = 0;
            sdfData[i+3] = 0;
        }
        
        // Add random occluders (walls/boxes)
        for (let o = 0; o < numOccluders; o++) {
            const cx = 50 + Math.random() * (WIDTH - 100);
            const cy = 50 + Math.random() * (HEIGHT - 100);
            const hw = 5 + Math.random() * 30;
            const hh = 5 + Math.random() * 60;
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    const sd = Math.max(Math.abs(x - cx) - hw, Math.abs(y - cy) - hh);
                    if (sd < sdfData[i]) {
                        sdfData[i] = sd;
                        sdfData[i+1] = 0;
                        sdfData[i+2] = 0;
                        sdfData[i+3] = 0;
                    }
                }
            }
        }
        
        // Add random emissive lights
        for (let l = 0; l < numLights; l++) {
            const cx = 30 + Math.random() * (WIDTH - 60);
            const cy = 30 + Math.random() * (HEIGHT - 60);
            const radius = 3 + Math.random() * 15;
            
            // Random color (HSL to RGB for nice colors)
            const h = Math.random();
            const s = 0.7 + Math.random() * 0.3;
            const L = 0.5 + Math.random() * 0.3;
            const c = (1 - Math.abs(2 * L - 1)) * s;
            const X = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = L - c / 2;
            let r, g, b;
            if (h < 1/6) { r = c; g = X; b = 0; }
            else if (h < 2/6) { r = X; g = c; b = 0; }
            else if (h < 3/6) { r = 0; g = c; b = X; }
            else if (h < 4/6) { r = 0; g = X; b = c; }
            else if (h < 5/6) { r = X; g = 0; b = c; }
            else { r = c; g = 0; b = X; }
            r += m; g += m; b += m;
            
            const intensity = 0.5 + Math.random() * 1.5;
            
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const i = (y * WIDTH + x) * 4;
                    const sd = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2) - radius;
                    if (sd < sdfData[i]) {
                        sdfData[i] = sd;
                        sdfData[i+1] = r * intensity;
                        sdfData[i+2] = g * intensity;
                        sdfData[i+3] = b * intensity;
                    }
                }
            }
        }
        
        device.queue.writeBuffer(sdfBuffers[0], 0, sdfData);
        device.queue.writeBuffer(sdfBuffers[1], 0, sdfData);
    }
    
    async function runFrequencyAnalysis() {
        // Simplified version of analyzeFrequency that returns data
        const stagingBuffer = device.createBuffer({
            size: totalSize * 16,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
        });
        
        const encoder = device.createCommandEncoder();
        encoder.copyBufferToBuffer(cascadeBuffer, 0, stagingBuffer, 0, totalSize * 16);
        device.queue.submit([encoder.finish()]);
        
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        const cascadeData = new Float32Array(stagingBuffer.getMappedRange().slice(0));
        stagingBuffer.unmap();
        stagingBuffer.destroy();
        
        const results = [];
        for (let lvl = 1; lvl < N_CASCADES; lvl++) {
            const lv = levels[lvl];
            const nDirs = lv.dRes;
            const numProbes = Math.min(16, lv.sRes * lv.sRes);
            const probeStep = Math.floor(lv.sRes * lv.sRes / numProbes);
            
            let totalBandwidth = 0;
            let totalMean = 0;
            let totalVariance = 0;
            let totalStdDev = 0;
            let totalPeakToAvg = 0;
            let totalNonZero = 0;
            
            for (let p = 0; p < numProbes; p++) {
                const probeIdx = p * probeStep;
                const angularSamples = [];
                for (let d = 0; d < nDirs; d++) {
                    const idx = lv.offset + probeIdx * nDirs + d;
                    const r = cascadeData[idx * 4 + 0];
                    const g = cascadeData[idx * 4 + 1];
                    const b = cascadeData[idx * 4 + 2];
                    angularSamples.push(r + g + b);
                }
                
                // 1. Bandwidth (existing)
                const mags = computeDFT(angularSamples);
                totalBandwidth += computeBandwidth(mags);
                
                // 2. Mean brightness
                const mean = angularSamples.reduce((a, b) => a + b, 0) / angularSamples.length;
                totalMean += mean;
                
                // 3. Variance
                const variance = angularSamples.reduce((sum, v) => sum + (v - mean) ** 2, 0) / angularSamples.length;
                totalVariance += variance;
                
                // 4. Standard deviation  
                totalStdDev += Math.sqrt(variance);
                
                // 5. Peak to average ratio (contrast)
                const peak = Math.max(...angularSamples);
                totalPeakToAvg += mean > 0.001 ? peak / mean : 1;
                
                // 6. Non-zero ratio (how many directions have light)
                const nonZeroCount = angularSamples.filter(v => v > 0.01).length;
                totalNonZero += nonZeroCount / angularSamples.length;
            }
            
            results.push({ 
                level: lvl, 
                bandwidth90: totalBandwidth / numProbes,
                mean: totalMean / numProbes,
                variance: totalVariance / numProbes,
                stdDev: totalStdDev / numProbes,
                peakToAvg: totalPeakToAvg / numProbes,
                nonZeroRatio: totalNonZero / numProbes
            });
        }
        return results;
    }
    
    async function runQualityComparison() {
        const savedArc = arcEnabled;
        const savedLevel = arcStartLevel;
        const savedMaxSkip = arcMaxSkip;
        const savedAutoMode = arcAutoMode;
        
        // IMPORTANT: Disable auto mode so our test values are used
        arcAutoMode = false;
        
        async function captureAfterFrames(n) {
            for (let i = 0; i < n; i++) {
                await new Promise(r => requestAnimationFrame(r));
            }
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = WIDTH;
            tempCanvas.height = HEIGHT;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            return tempCtx.getImageData(0, 0, WIDTH, HEIGHT).data;
        }
        
        arcEnabled = 0;
        arcMaxSkip = 2;
        const refImage = await captureAfterFrames(20);
        
        // L2 (~40%): startLevel=2, maxSkip=2
        arcEnabled = 1;
        arcStartLevel = 2;
        arcMaxSkip = 2;
        const arcLevel2Image = await captureAfterFrames(20);
        
        // L3 (~25%): startLevel=3, maxSkip=2
        arcStartLevel = 3;
        arcMaxSkip = 2;
        const arcLevel3Image = await captureAfterFrames(20);
        
        // L4 (~17%): startLevel=3, maxSkip=1
        arcStartLevel = 3;
        arcMaxSkip = 1;
        const arcLevel4Image = await captureAfterFrames(20);
        
        // L5 (~10%): startLevel=4, maxSkip=2
        arcStartLevel = 4;
        arcMaxSkip = 2;
        const arcLevel5Image = await captureAfterFrames(20);
        
        arcEnabled = savedArc;
        arcStartLevel = savedLevel;
        arcMaxSkip = savedMaxSkip;
        arcAutoMode = savedAutoMode;
        
        return {
            level2: {
                psnr: computePSNR(refImage, arcLevel2Image),
                ssim: computeSSIM(refImage, arcLevel2Image, WIDTH, HEIGHT)
            },
            level3: {
                psnr: computePSNR(refImage, arcLevel3Image),
                ssim: computeSSIM(refImage, arcLevel3Image, WIDTH, HEIGHT)
            },
            level4: {
                psnr: computePSNR(refImage, arcLevel4Image),
                ssim: computeSSIM(refImage, arcLevel4Image, WIDTH, HEIGHT)
            },
            level5: {
                psnr: computePSNR(refImage, arcLevel5Image),
                ssim: computeSSIM(refImage, arcLevel5Image, WIDTH, HEIGHT)
            }
        };
    }
    
    async function runFullBenchmark() {
        benchmarkBtn.textContent = 'Running...';
        benchmarkBtn.disabled = true;
        analyzeBtn.disabled = true;
        compareBtn.disabled = true;
        
        const allResults = [];
        
        // 50 test configurations for statistical robustness
        const configs = [];
        
        // Systematic coverage: lights 1-50, occluders 1-10
        // This gives us a good spread to validate correlations
        const lightCounts = [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 18, 20, 25, 30, 35, 40, 45, 50];
        const occluderCounts = [1, 2, 3, 4, 5, 6, 8, 10];
        
        // Generate diverse combinations (not all pairs - that would be 152 configs)
        // Instead, pick ~50 representative combinations
        for (const lights of lightCounts) {
            // For each light count, test 2-3 occluder settings
            const occOptions = lights <= 5 ? [1, 3] : 
                               lights <= 15 ? [2, 5, 8] : 
                               [3, 5, 8];
            for (const occ of occOptions) {
                if (configs.length < 50) {
                    configs.push({ lights, occluders: occ, name: `${lights}L/${occ}O` });
                }
            }
        }
        
        console.log(`Running benchmark with ${configs.length} scene configurations...`);
        
        spectrumCanvas.style.display = 'none';
        spectrumInfo.style.display = 'block';
        
        for (let i = 0; i < configs.length; i++) {
            const cfg = configs[i];
            spectrumInfo.innerHTML = `<b>Running Benchmark ${i + 1}/${configs.length}: ${cfg.name}</b><br>Please wait...`;
            
            // Create scene
            createRandomScene(cfg.lights, cfg.occluders);
            
            // For frequency analysis, use ARC OFF to measure TRUE frequency content
            arcEnabled = 0;
            
            // Wait for rendering to stabilize
            for (let f = 0; f < 30; f++) {
                await new Promise(r => requestAnimationFrame(r));
            }
            
            // Run frequency analysis (with ARC OFF)
            const freqResults = await runFrequencyAnalysis();
            
            // Calculate what level Auto would choose based on Mean + StdDev score
            // Combined score gives smoother progression than Mean alone
            // L2 is NOT used - no signal reliably predicts L2 safety
            // Thresholds calibrated on 50-scene benchmark to GUARANTEE >50 dB PSNR
            const l1Mean = freqResults[0] ? freqResults[0].mean : 0.3;
            const l1StdDev = freqResults[0] ? freqResults[0].stdDev : 0.3;
            const score = l1Mean + l1StdDev;
            
            let autoLevel, autoMaxSkip, autoMode;
            if (score < 0.45) {
                autoLevel = 4; autoMaxSkip = 2; autoMode = 'L5';  // Very simple - needs conservative
            } else if (score < 1.00) {
                autoLevel = 3; autoMaxSkip = 1; autoMode = 'L4';  // Simple to moderate
            } else {
                autoLevel = 3; autoMaxSkip = 2; autoMode = 'L3';  // Complex scenes only (score >= 1.0)
            }
            
            // Run quality comparison (this manages its own ARC states)
            const qualityResults = await runQualityComparison();
            
            // Get the PSNR for the auto-chosen mode
            let autoPSNR, autoSSIM;
            if (autoMode === 'L5') {
                autoPSNR = qualityResults.level5.psnr;
                autoSSIM = qualityResults.level5.ssim;
            } else if (autoMode === 'L4') {
                autoPSNR = qualityResults.level4.psnr;
                autoSSIM = qualityResults.level4.ssim;
            } else if (autoMode === 'L3') {
                autoPSNR = qualityResults.level3.psnr;
                autoSSIM = qualityResults.level3.ssim;
            } else {
                autoPSNR = qualityResults.level2.psnr;
                autoSSIM = qualityResults.level2.ssim;
            }
            
            allResults.push({
                config: cfg,
                frequency: freqResults,
                quality: qualityResults,
                autoMode: autoMode,
                autoPSNR: autoPSNR,
                autoSSIM: autoSSIM
            });
        }
        
        // Restore original state
        arcEnabled = 1;
        arcStartLevel = 3;
        arcMaxSkip = 2;
        
        // Display consolidated results
        let html = `<b>Full Benchmark Results (${configs.length} Scenes)</b><br><br>`;
        
        // Signal Analysis - show multiple signals to find best correlation
        html += '<b>Signal Analysis (L1 level):</b><br>';
        html += '<table style="margin:0 auto; text-align:center; border-collapse:collapse; font-size:10px;">';
        html += '<tr style="border-bottom:1px solid #444;"><th style="padding:2px 4px;">Scene</th><th style="padding:2px 4px;">Mean</th><th style="padding:2px 4px;">StdDev</th><th style="padding:2px 4px;">Score</th><th style="padding:2px 4px;">Peak/Avg</th><th style="padding:2px 4px;">NonZero</th></tr>';
        
        let avgBW = [0, 0, 0, 0];
        for (const r of allResults) {
            const f = r.frequency[0]; // L1
            const score = f ? (f.mean + f.stdDev).toFixed(2) : '-';
            html += `<tr><td style="padding:2px 4px; text-align:left;">${r.config.lights}L/${r.config.occluders}O</td>`;
            html += `<td style="padding:2px 4px;">${f ? f.mean.toFixed(2) : '-'}</td>`;
            html += `<td style="padding:2px 4px;">${f ? f.stdDev.toFixed(2) : '-'}</td>`;
            html += `<td style="padding:2px 4px; color:#8f8;">${score}</td>`;
            html += `<td style="padding:2px 4px;">${f ? f.peakToAvg.toFixed(2) : '-'}</td>`;
            html += `<td style="padding:2px 4px;">${f ? (f.nonZeroRatio * 100).toFixed(1) + '%' : '-'}</td>`;
            html += '</tr>';
            
            // Still track bandwidth for backward compat
            for (let l = 0; l < 4; l++) {
                if (r.frequency[l]) avgBW[l] += r.frequency[l].bandwidth90;
            }
        }
        html += '</table><br>';
        
        // Quality summary - L5 (~10%), L4 (~17%), L3 (~25%), L2 (~40%)
        html += '<b>Quality Comparison (vs ARC OFF):</b><br>';
        html += '<table style="margin:0 auto; text-align:center; border-collapse:collapse; font-size:10px;">';
        html += '<tr style="border-bottom:1px solid #444;"><th style="padding:2px 4px;">Scene</th><th style="padding:2px 4px;">L5(10%)</th><th style="padding:2px 4px;">L4(17%)</th><th style="padding:2px 4px;">L3(25%)</th><th style="padding:2px 4px;">L2(40%)</th><th style="padding:2px 4px;" colspan="2">Auto</th></tr>';
        
        let sumL5PSNR = 0, sumL4PSNR = 0, sumL3PSNR = 0, sumL2PSNR = 0;
        let minL5PSNR = Infinity, minL4PSNR = Infinity, minL3PSNR = Infinity, minL2PSNR = Infinity;
        let maxL5PSNR = 0, maxL4PSNR = 0, maxL3PSNR = 0, maxL2PSNR = 0;
        let sumAutoPSNR = 0, minAutoPSNR = Infinity, maxAutoPSNR = 0;
        let autoModeCounts = {'L5': 0, 'L4': 0, 'L3': 0, 'L2': 0};
        
        for (const r of allResults) {
            const l5p = r.quality.level5.psnr;
            const l4p = r.quality.level4.psnr;
            const l3p = r.quality.level3.psnr;
            const l2p = r.quality.level2.psnr;
            
            html += `<tr>`;
            html += `<td style="padding:2px 4px; text-align:left;">${r.config.lights}L/${r.config.occluders}O</td>`;
            html += `<td style="padding:2px 4px;">${l5p === Infinity ? 'âˆž' : l5p.toFixed(1)}</td>`;
            html += `<td style="padding:2px 4px;">${l4p === Infinity ? 'âˆž' : l4p.toFixed(1)}</td>`;
            html += `<td style="padding:2px 4px;">${l3p === Infinity ? 'âˆž' : l3p.toFixed(1)}</td>`;
            html += `<td style="padding:2px 4px;">${l2p === Infinity ? 'âˆž' : l2p.toFixed(1)}</td>`;
            html += `<td style="padding:2px 4px; color:#8f8;">${r.autoMode}</td>`;
            html += `<td style="padding:2px 4px; color:#8f8;">${r.autoPSNR === Infinity ? 'âˆž' : r.autoPSNR.toFixed(1)}</td>`;
            html += '</tr>';
            
            if (l5p !== Infinity) { sumL5PSNR += l5p; minL5PSNR = Math.min(minL5PSNR, l5p); maxL5PSNR = Math.max(maxL5PSNR, l5p); }
            if (l4p !== Infinity) { sumL4PSNR += l4p; minL4PSNR = Math.min(minL4PSNR, l4p); maxL4PSNR = Math.max(maxL4PSNR, l4p); }
            if (l3p !== Infinity) { sumL3PSNR += l3p; minL3PSNR = Math.min(minL3PSNR, l3p); maxL3PSNR = Math.max(maxL3PSNR, l3p); }
            if (l2p !== Infinity) { sumL2PSNR += l2p; minL2PSNR = Math.min(minL2PSNR, l2p); maxL2PSNR = Math.max(maxL2PSNR, l2p); }
            
            if (r.autoPSNR !== Infinity) { sumAutoPSNR += r.autoPSNR; minAutoPSNR = Math.min(minAutoPSNR, r.autoPSNR); maxAutoPSNR = Math.max(maxAutoPSNR, r.autoPSNR); }
            autoModeCounts[r.autoMode]++;
        }
        
        html += '</table><br>';
        
        // Calculate average ray reduction for Auto mode
        const autoAvgReduction = (autoModeCounts['L5'] * 10 + autoModeCounts['L4'] * 17 + autoModeCounts['L3'] * 25 + autoModeCounts['L2'] * 40) / allResults.length;
        
        // Summary statistics
        html += '<b>Summary:</b><br>';
        html += '<table style="margin:0 auto; text-align:left; border-collapse:collapse;">';
        html += `<tr><td style="padding:2px 8px;">L5 (~10%) PSNR:</td><td style="padding:2px 8px;">${minL5PSNR.toFixed(1)} - ${maxL5PSNR.toFixed(1)} dB (avg: ${(sumL5PSNR/allResults.length).toFixed(1)})</td></tr>`;
        html += `<tr><td style="padding:2px 8px;">L4 (~17%) PSNR:</td><td style="padding:2px 8px;">${minL4PSNR.toFixed(1)} - ${maxL4PSNR.toFixed(1)} dB (avg: ${(sumL4PSNR/allResults.length).toFixed(1)})</td></tr>`;
        html += `<tr><td style="padding:2px 8px;">L3 (~25%) PSNR:</td><td style="padding:2px 8px;">${minL3PSNR.toFixed(1)} - ${maxL3PSNR.toFixed(1)} dB (avg: ${(sumL3PSNR/allResults.length).toFixed(1)})</td></tr>`;
        html += `<tr><td style="padding:2px 8px;">L2 (~40%) PSNR:</td><td style="padding:2px 8px;">${minL2PSNR.toFixed(1)} - ${maxL2PSNR.toFixed(1)} dB (avg: ${(sumL2PSNR/allResults.length).toFixed(1)})</td></tr>`;
        html += `<tr style="color:#8f8;"><td style="padding:2px 8px;">Auto (~${autoAvgReduction.toFixed(0)}%) PSNR:</td><td style="padding:2px 8px;">${minAutoPSNR.toFixed(1)} - ${maxAutoPSNR.toFixed(1)} dB (avg: ${(sumAutoPSNR/allResults.length).toFixed(1)})</td></tr>`;
        html += `<tr><td style="padding:2px 8px;">Avg L3+ bandwidth:</td><td style="padding:2px 8px;">${((avgBW[2] + avgBW[3]) / (allResults.length * 2) * 100).toFixed(1)}% of Nyquist</td></tr>`;
        html += `<tr><td style="padding:2px 8px;">Auto mode choices:</td><td style="padding:2px 8px;">L5: ${autoModeCounts['L5']}, L4: ${autoModeCounts['L4']}, L3: ${autoModeCounts['L3']}, L2: ${autoModeCounts['L2']}</td></tr>`;
        html += '</table>';
        
        // Conclusion
        const allL5Above50 = allResults.every(r => r.quality.level5.psnr >= 50 || r.quality.level5.psnr === Infinity);
        const allL4Above50 = allResults.every(r => r.quality.level4.psnr >= 50 || r.quality.level4.psnr === Infinity);
        const allL3Above50 = allResults.every(r => r.quality.level3.psnr >= 50 || r.quality.level3.psnr === Infinity);
        const allL2Above50 = allResults.every(r => r.quality.level2.psnr >= 50 || r.quality.level2.psnr === Infinity);
        const allAutoAbove50 = allResults.every(r => r.autoPSNR >= 50 || r.autoPSNR === Infinity);
        
        html += '<br><b>Conclusion:</b><br>';
        if (allL5Above50) {
            html += 'ðŸŸ¢ L5 (~10% reduction): ALL scenes >50 dB PSNR (visually identical)<br>';
        } else {
            html += 'ðŸŸ¡ L5 (~10% reduction): Some scenes <50 dB PSNR<br>';
        }
        if (allL4Above50) {
            html += 'ðŸŸ¢ L4 (~17% reduction): ALL scenes >50 dB PSNR (visually identical)<br>';
        } else {
            html += 'ðŸŸ¡ L4 (~17% reduction): Some scenes <50 dB PSNR<br>';
        }
        if (allL3Above50) {
            html += 'ðŸŸ¢ L3 (~25% reduction): ALL scenes >50 dB PSNR (visually identical)<br>';
        } else {
            html += 'ðŸŸ¡ L3 (~25% reduction): Some scenes <50 dB PSNR<br>';
        }
        if (allL2Above50) {
            html += 'ðŸŸ¢ L2 (~40% reduction): ALL scenes >50 dB PSNR (visually identical)<br>';
        } else {
            html += 'ðŸŸ¡ L2 (~40% reduction): Some scenes <50 dB PSNR<br>';
        }
        if (allAutoAbove50) {
            html += `ðŸŸ¢ <b>Auto (~${autoAvgReduction.toFixed(0)}% avg reduction): ALL scenes >50 dB PSNR</b><br>`;
        } else {
            html += `ðŸŸ¡ Auto (~${autoAvgReduction.toFixed(0)}% avg reduction): Some scenes <50 dB PSNR<br>`;
        }
        
        spectrumInfo.innerHTML = html;
        
        // Console output for paper
        console.log('=== FULL BENCHMARK RESULTS ===');
        console.log('');
        console.log('Signal Analysis (L1 level) - looking for correlation with scene complexity:');
        console.log('Scene       | BW90%  | Mean   | StdDev | Pk/Avg | NonZero | L2 PSNR');
        console.log('------------|--------|--------|--------|--------|---------|--------');
        for (const r of allResults) {
            const f = r.frequency[0];
            const l2psnr = r.quality.level2.psnr;
            console.log(`${(r.config.lights + 'L/' + r.config.occluders + 'O').padEnd(11)} | ${(f.bandwidth90*100).toFixed(1).padStart(5)}% | ${f.mean.toFixed(2).padStart(6)} | ${f.stdDev.toFixed(2).padStart(6)} | ${f.peakToAvg.toFixed(2).padStart(6)} | ${(f.nonZeroRatio*100).toFixed(1).padStart(6)}% | ${l2psnr.toFixed(1).padStart(6)}`);
        }
        console.log('');
        console.log('Quality Comparison:');
        for (const r of allResults) {
            console.log(`  ${r.config.name}:`);
            console.log(`    L5 (~10%): PSNR=${r.quality.level5.psnr.toFixed(1)} dB`);
            console.log(`    L4 (~17%): PSNR=${r.quality.level4.psnr.toFixed(1)} dB`);
            console.log(`    L3 (~25%): PSNR=${r.quality.level3.psnr.toFixed(1)} dB`);
            console.log(`    L2 (~40%): PSNR=${r.quality.level2.psnr.toFixed(1)} dB`);
            console.log(`    Auto chose ${r.autoMode}: PSNR=${r.autoPSNR.toFixed(1)} dB`);
        }
        console.log('');
        console.log('Summary:');
        console.log(`  L5 (~10%) PSNR range: ${minL5PSNR.toFixed(1)} - ${maxL5PSNR.toFixed(1)} dB (avg: ${(sumL5PSNR/allResults.length).toFixed(1)})`);
        console.log(`  L4 (~17%) PSNR range: ${minL4PSNR.toFixed(1)} - ${maxL4PSNR.toFixed(1)} dB (avg: ${(sumL4PSNR/allResults.length).toFixed(1)})`);
        console.log(`  L3 (~25%) PSNR range: ${minL3PSNR.toFixed(1)} - ${maxL3PSNR.toFixed(1)} dB (avg: ${(sumL3PSNR/allResults.length).toFixed(1)})`);
        console.log(`  L2 (~40%) PSNR range: ${minL2PSNR.toFixed(1)} - ${maxL2PSNR.toFixed(1)} dB (avg: ${(sumL2PSNR/allResults.length).toFixed(1)})`);
        console.log(`  Auto (~${autoAvgReduction.toFixed(0)}%) PSNR range: ${minAutoPSNR.toFixed(1)} - ${maxAutoPSNR.toFixed(1)} dB (avg: ${(sumAutoPSNR/allResults.length).toFixed(1)})`);
        console.log(`  Auto mode choices: L5=${autoModeCounts['L5']}, L4=${autoModeCounts['L4']}, L3=${autoModeCounts['L3']}, L2=${autoModeCounts['L2']}`);
        console.log(`  Average L3+ bandwidth: ${((avgBW[2] + avgBW[3]) / (allResults.length * 2) * 100).toFixed(1)}% of Nyquist`);
        
        // Correlation analysis - find which signal correlates best with L2 PSNR
        console.log('');
        console.log('=== CORRELATION ANALYSIS ===');
        console.log(`Sample size: n = ${allResults.length}`);
        console.log('Looking for signal that correlates with L2 PSNR (higher L2 PSNR = can use more aggressive)');
        
        function correlation(xs, ys) {
            const n = xs.length;
            const sumX = xs.reduce((a,b) => a+b, 0);
            const sumY = ys.reduce((a,b) => a+b, 0);
            const sumXY = xs.reduce((acc, x, i) => acc + x * ys[i], 0);
            const sumX2 = xs.reduce((a,b) => a + b*b, 0);
            const sumY2 = ys.reduce((a,b) => a + b*b, 0);
            const num = n * sumXY - sumX * sumY;
            const den = Math.sqrt((n * sumX2 - sumX*sumX) * (n * sumY2 - sumY*sumY));
            return den === 0 ? 0 : num / den;
        }
        
        // Fisher z-transformation for confidence intervals
        function correlationCI(r, n) {
            const z = 0.5 * Math.log((1 + r) / (1 - r)); // Fisher z
            const se = 1 / Math.sqrt(n - 3);
            const zCrit = 1.96; // 95% CI
            const zLow = z - zCrit * se;
            const zHigh = z + zCrit * se;
            // Transform back
            const rLow = (Math.exp(2 * zLow) - 1) / (Math.exp(2 * zLow) + 1);
            const rHigh = (Math.exp(2 * zHigh) - 1) / (Math.exp(2 * zHigh) + 1);
            return { r, low: rLow, high: rHigh };
        }
        
        const l2psnrs = allResults.map(r => r.quality.level2.psnr);
        const bw90s = allResults.map(r => r.frequency[0].bandwidth90);
        const means = allResults.map(r => r.frequency[0].mean);
        const stdDevs = allResults.map(r => r.frequency[0].stdDev);
        const scores = allResults.map(r => r.frequency[0].mean + r.frequency[0].stdDev);
        const peakToAvgs = allResults.map(r => r.frequency[0].peakToAvg);
        const nonZeros = allResults.map(r => r.frequency[0].nonZeroRatio);
        const sceneLightCounts = allResults.map(r => r.config.lights);
        
        const corrN = allResults.length;
        const corrBW = correlationCI(correlation(bw90s, l2psnrs), corrN);
        const corrMean = correlationCI(correlation(means, l2psnrs), corrN);
        const corrStdDev = correlationCI(correlation(stdDevs, l2psnrs), corrN);
        const corrScore = correlationCI(correlation(scores, l2psnrs), corrN);
        const corrPkAvg = correlationCI(correlation(peakToAvgs, l2psnrs), corrN);
        const corrNZ = correlationCI(correlation(nonZeros, l2psnrs), corrN);
        const corrLight = correlationCI(correlation(sceneLightCounts, l2psnrs), corrN);
        
        console.log(`  Correlation with L2 PSNR (95% CI):`);
        console.log(`    BW90:         ${corrBW.r.toFixed(3)} [${corrBW.low.toFixed(3)}, ${corrBW.high.toFixed(3)}]`);
        console.log(`    Mean:         ${corrMean.r.toFixed(3)} [${corrMean.low.toFixed(3)}, ${corrMean.high.toFixed(3)}]`);
        console.log(`    StdDev:       ${corrStdDev.r.toFixed(3)} [${corrStdDev.low.toFixed(3)}, ${corrStdDev.high.toFixed(3)}]`);
        console.log(`    Mean+StdDev:  ${corrScore.r.toFixed(3)} [${corrScore.low.toFixed(3)}, ${corrScore.high.toFixed(3)}] â† used for adaptive`);
        console.log(`    Peak/Avg:     ${corrPkAvg.r.toFixed(3)} [${corrPkAvg.low.toFixed(3)}, ${corrPkAvg.high.toFixed(3)}]`);
        console.log(`    NonZero:      ${corrNZ.r.toFixed(3)} [${corrNZ.low.toFixed(3)}, ${corrNZ.high.toFixed(3)}]`);
        console.log(`    LightCount:   ${corrLight.r.toFixed(3)} [${corrLight.low.toFixed(3)}, ${corrLight.high.toFixed(3)}] (ground truth)`);
        console.log('');
        console.log('  (Positive = higher signal â†’ higher L2 PSNR = can be aggressive when signal is HIGH)');
        console.log('  (Negative = higher signal â†’ lower L2 PSNR = need conservative when signal is HIGH)');
        console.log('  Statistical significance: 95% CI not crossing 0 means p < 0.05');
        
        // Update HTML with correlation table
        let corrHtml = '<br><b>Correlation Analysis (n=' + corrN + ', 95% CI):</b><br>';
        corrHtml += '<table style="margin:0 auto; text-align:left; border-collapse:collapse; font-size:10px;">';
        corrHtml += '<tr style="border-bottom:1px solid #444;"><th style="padding:2px 6px;">Signal</th><th style="padding:2px 6px;">r</th><th style="padding:2px 6px;">95% CI</th><th style="padding:2px 6px;">Interpretation</th></tr>';
        corrHtml += `<tr><td>LightCount</td><td>${corrLight.r.toFixed(2)}</td><td>[${corrLight.low.toFixed(2)}, ${corrLight.high.toFixed(2)}]</td><td style="color:#888;">Ground truth</td></tr>`;
        corrHtml += `<tr style="color:#8f8;"><td><b>Mean+StdDev</b></td><td><b>${corrScore.r.toFixed(2)}</b></td><td>[${corrScore.low.toFixed(2)}, ${corrScore.high.toFixed(2)}]</td><td>âœ“ Best measurable</td></tr>`;
        corrHtml += `<tr><td>Mean</td><td>${corrMean.r.toFixed(2)}</td><td>[${corrMean.low.toFixed(2)}, ${corrMean.high.toFixed(2)}]</td><td></td></tr>`;
        corrHtml += `<tr><td>StdDev</td><td>${corrStdDev.r.toFixed(2)}</td><td>[${corrStdDev.low.toFixed(2)}, ${corrStdDev.high.toFixed(2)}]</td><td></td></tr>`;
        corrHtml += `<tr><td>NonZero</td><td>${corrNZ.r.toFixed(2)}</td><td>[${corrNZ.low.toFixed(2)}, ${corrNZ.high.toFixed(2)}]</td><td></td></tr>`;
        corrHtml += `<tr><td>Peak/Avg</td><td>${corrPkAvg.r.toFixed(2)}</td><td>[${corrPkAvg.low.toFixed(2)}, ${corrPkAvg.high.toFixed(2)}]</td><td></td></tr>`;
        corrHtml += `<tr style="color:#f88;"><td>BW90</td><td>${corrBW.r.toFixed(2)}</td><td>[${corrBW.low.toFixed(2)}, ${corrBW.high.toFixed(2)}]</td><td>âœ— ${corrBW.high < 0 ? 'Significantly negative!' : 'Wrong direction'}</td></tr>`;
        corrHtml += '</table>';
        
        spectrumInfo.innerHTML += corrHtml;
        
        benchmarkBtn.textContent = 'Run Full Benchmark';
        benchmarkBtn.disabled = false;
        analyzeBtn.disabled = false;
        compareBtn.disabled = false;
    }
    
    benchmarkBtn.onclick = runFullBenchmark;
    
    // Adaptive level analysis based on scene complexity
    // Uses Mean + StdDev combined score (both correlate ~0.8 with quality tolerance)
    // Higher score = more lights = complex scene = can use aggressive skipping
    // L2 is NOT used - no signal reliably predicts L2 safety
    let lastAdaptiveAnalysis = 0;
    
    async function analyzeSceneForAdaptiveLevel() {
        // Quick analysis on L1 - compute Mean + StdDev (combined score correlates better!)
        const stagingBuffer = device.createBuffer({
            size: totalSize * 16,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
        });
        
        const encoder = device.createCommandEncoder();
        encoder.copyBufferToBuffer(cascadeBuffer, 0, stagingBuffer, 0, totalSize * 16);
        device.queue.submit([encoder.finish()]);
        
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        const cascadeData = new Float32Array(stagingBuffer.getMappedRange().slice(0));
        stagingBuffer.unmap();
        stagingBuffer.destroy();
        
        // Analyze L1 Mean + StdDev (level 1)
        const lv = levels[1];
        const nDirs = lv.dRes;
        const numProbes = Math.min(8, lv.sRes * lv.sRes);
        const probeStep = Math.floor(lv.sRes * lv.sRes / numProbes);
        
        let totalMean = 0;
        let totalStdDev = 0;
        for (let p = 0; p < numProbes; p++) {
            const probeIdx = p * probeStep;
            const samples = [];
            for (let d = 0; d < nDirs; d++) {
                const idx = lv.offset + probeIdx * nDirs + d;
                const r = cascadeData[idx * 4 + 0];
                const g = cascadeData[idx * 4 + 1];
                const b = cascadeData[idx * 4 + 2];
                samples.push(r + g + b);
            }
            const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
            const variance = samples.reduce((sum, v) => sum + (v - mean) ** 2, 0) / samples.length;
            totalMean += mean;
            totalStdDev += Math.sqrt(variance);
        }
        
        const avgMean = totalMean / numProbes;
        const avgStdDev = totalStdDev / numProbes;
        
        // COMBINED SIGNAL adaptive thresholds
        // Using Mean + StdDev for smoother progression (both correlate ~0.7-0.8 with quality)
        // This fixes the issue where 5L had lower Mean than 3L despite more lights
        //
        // L2 is NOT used in auto mode - no signal reliably predicts L2 safety
        // (50L can use L2 safely but its score is LOWER than 30L which can't)
        //
        // Thresholds calibrated on 50-scene benchmark to GUARANTEE >50 dB PSNR:
        // < 0.45 â†’ L5: simplest scenes (need conservative to avoid aliasing)
        // < 1.00 â†’ L4: simple to moderate scenes  
        // >= 1.00 â†’ L3: complex scenes only (many lights = smooth angular distribution)
        const score = avgMean + avgStdDev;
        
        let newLevel, newMaxSkip;
        if (score < 0.45) {
            newLevel = 4; newMaxSkip = 2;  // L5: very simple
        } else if (score < 1.00) {
            newLevel = 3; newMaxSkip = 1;  // L4: simple to moderate
        } else {
            newLevel = 3; newMaxSkip = 2;  // L3: complex scenes only (no L2 - not safe)
        }
        
        if (newLevel !== adaptiveLevel || newMaxSkip !== adaptiveMaxSkip) {
            adaptiveLevel = newLevel;
            adaptiveMaxSkip = newMaxSkip;
            updateConservativeBtn();
            const modeStr = (newLevel === 4) ? 'L5' : (newMaxSkip === 1 ? 'L4' : 'L3');
            console.log(`Adaptive ARC: Mean=${avgMean.toFixed(2)}, StdDev=${avgStdDev.toFixed(2)}, Score=${score.toFixed(2)} â†’ ${modeStr}`);
        }
    }
    
    // Initialize button states and stats
    updateConservativeBtn();
    updateStatsNow();

    const screenDiag = Math.hypot(WIDTH, HEIGHT);
    const c0_interval = screenDiag * 4 / ((1 << (2 * N_CASCADES)) - 1);
    let frame = 0, pingPong = 0;

    function render() {
        // Adaptive level analysis (hot start at frame 5 + every 60 frames in auto mode)
        if (arcAutoMode && (frame === 5 || (frame > 5 && frame % 60 === 0))) {
            analyzeSceneForAdaptiveLevel();
        }
        
        // Update uniforms - must match struct layout exactly
        const uniformData = new ArrayBuffer(64);
        const f32 = new Float32Array(uniformData);
        const u32 = new Uint32Array(uniformData);
        f32[0] = performance.now() / 1000;  // time
        u32[1] = frame;                      // frame
        u32[2] = arcEnabled;                 // arcEnabled
        u32[3] = getEffectiveLevel();        // arcStartLevel (effective)
        u32[4] = getEffectiveMaxSkip();      // arcMaxSkip (effective)
        f32[5] = mouse.x;                    // mouseX
        f32[6] = mouse.y;                    // mouseY
        f32[7] = mouse.px;                   // mousePX
        f32[8] = mouse.py;                   // mousePY
        u32[9] = mouse.down ? 1 : 0;         // mouseDown
        u32[10] = emissive;                  // emissive
        f32[11] = hue;                       // hue
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);
        
        if (mouse.down) { hue = (hue + 0.002) % 1.0; }

        // SDF Update
        const sdfIn = sdfBuffers[pingPong], sdfOut = sdfBuffers[1 - pingPong];
        const sdfBG = device.createBindGroup({
            layout: sdfUpdatePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
                { binding: 1, resource: { buffer: sdfIn } },
                { binding: 2, resource: { buffer: sdfOut } }
            ]
        });
        
        let encoder = device.createCommandEncoder();
        let pass = encoder.beginComputePass();
        pass.setPipeline(sdfUpdatePipeline);
        pass.setBindGroup(0, sdfBG);
        pass.dispatchWorkgroups(Math.ceil(WIDTH/8), Math.ceil(HEIGHT/8));
        pass.end();
        device.queue.submit([encoder.finish()]);

        // Cascade bind group
        const cascadeBG = device.createBindGroup({
            layout: cascadePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: uniformBuffer } },
                { binding: 1, resource: { buffer: sdfOut } },
                { binding: 2, resource: { buffer: cascadeBuffer } },
                { binding: 3, resource: { buffer: paramsBuffer } }
            ]
        });

        // Compute cascades
        for (let level = N_CASCADES - 1; level >= 0; level--) {
            const lv = levels[level];
            const tMin = level === 0 ? 0 : c0_interval * (1 << (2 * (level - 1)));
            const tMax = c0_interval * (1 << (2 * level));
            
            const paramsData = new ArrayBuffer(32);
            new Uint32Array(paramsData, 0, 4).set([level, lv.sRes, lv.dRes, lv.offset]);
            new Float32Array(paramsData, 16, 2).set([tMin, tMax]);
            device.queue.writeBuffer(paramsBuffer, 0, paramsData);
            
            encoder = device.createCommandEncoder();
            pass = encoder.beginComputePass();
            pass.setPipeline(cascadePipeline);
            pass.setBindGroup(0, cascadeBG);
            pass.dispatchWorkgroups(Math.ceil(lv.size / 64));
            pass.end();
            device.queue.submit([encoder.finish()]);
        }

        // Render
        const renderBG = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: sdfOut } },
                { binding: 1, resource: { buffer: cascadeBuffer } }
            ]
        });
        
        encoder = device.createCommandEncoder();
        pass = encoder.beginRenderPass({
            colorAttachments: [{ view: ctx.getCurrentTexture().createView(), clearValue: {r:0,g:0,b:0,a:1}, loadOp: 'clear', storeOp: 'store' }]
        });
        pass.setPipeline(renderPipeline);
        pass.setBindGroup(0, renderBG);
        pass.draw(6);
        pass.end();
        device.queue.submit([encoder.finish()]);

        // Update frame timing
        const now = performance.now();
        const frameTime = now - lastTime;
        lastTime = now;
        frameTimes.push(frameTime);
        if (frameTimes.length > 60) frameTimes.shift();
        
        // Calculate stats every 30 frames
        if (frame % 30 === 0) {
            const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
            const fps = 1000 / avgFrameTime;
            
            const currentRays = arcEnabled ? getRaysForCurrentSettings() : raysNoArc;
            const savedRays = raysNoArc - currentRays;
            const savedPercent = ((savedRays / raysNoArc) * 100).toFixed(1);
            
            const formatRays = (n) => n >= 1000000 ? (n/1000000).toFixed(1) + 'M' : (n/1000).toFixed(0) + 'K';
            
            stats.innerHTML = `
                <span>FPS: <b>${fps.toFixed(1)}</b></span>
                <span>Frame: <b>${avgFrameTime.toFixed(2)} ms</b></span>
                <span>Rays: <b>${formatRays(currentRays)}</b> / ${formatRays(raysNoArc)}</span>
                <span class="${arcEnabled ? 'good' : 'neutral'}">Saved: <b>${arcEnabled ? savedPercent + '%' : '0%'}</b></span>
            `;
        }

        pingPong = 1 - pingPong;
        frame++;
        requestAnimationFrame(render);
    }
    
    render();
}
main();
    </script>
</body>
</html>
